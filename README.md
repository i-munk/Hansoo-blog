# Hansoo-blog

[로켓부스트]블록체인 엔지니어 부트캠프 OT
25.01.31

-전반적인 커리큘럼 강의
-내일배움카드 신청 익일 수강신청
-비트코인 백서읽어보기
-하루에 한번 블로그작성하기


터미널 연습
Last login: Fri Jan 31 11:19:11 on console
sh@Sui-MacBookPro ~ % pwd       
/Users/sh
sh@Sui-MacBookPro ~ % ls
Desktop		Downloads	Movies		Pictures
Documents	Library		Music		Public
sh@Sui-MacBookPro ~ % cd Desktop
sh@Sui-MacBookPro Desktop % pwd
/Users/sh/Desktop
sh@Sui-MacBookPro Desktop % mkdir 임한수
sh@Sui-MacBookPro Desktop % ls
임한수
sh@Sui-MacBookPro Desktop % touch test.txt
sh@Sui-MacBookPro Desktop % ls
test.txt	임한수
sh@Sui-MacBookPro Desktop % cd 임한수
sh@Sui-MacBookPro 임한수 % touch test.txt
sh@Sui-MacBookPro 임한수 % ls
test.txt
sh@Sui-MacBookPro 임한수 % vim test.txt

논릭적사고문제
1. [12,38,91,45,23,7,5]
2. A
3. 4
4. [D,C,A,B,E] 345
5. (2,5)(5,3)(3,6)(6,1)
6. 규칙:+4+2씩 숫자:42
7. 9,18,27,36,39,48
8. C
9. 4213
10. 규칙:앞의 숫자 + x*2 숫자:63


-2월3일 
블록체인은 데이터를 블록단위로 저장하고 이를 체인형태로 연결하여 분산된 네트워크에서 관리하는 기술입니다. 중앙기관없이 참여자들이 공동으로 데이터를 검증하고 저장하는 **분산 원장 기술(DLT)**의 한 형태입니다.

블록채인의 주요 특징 
탈중앙화: 중앙 기관 없이 P2P 네트워크로 운영
변조 불가능성: 데이터를 위조하거나 수정할 수 없음
보안성: 암호화 기술을 활용해 높은 신뢰성 보장
투명성: 누구나 거래내역을 확인할 수 있음
스마트 컨트렉트: 자동화된 계약 기능 제공

-블록체인 기술의 기원과 등장 이유
1. 신뢰 문제 해결
기존 금융 시스템에서는 **중앙기관(은행,정부0**이 신뢰를 보장하지만, 높은 수수료, 거래지연, 데이트 조작가능성 이런 문제를 해결하기 위해 블록체인 등장
2. 비트코인의 등장
**2008년, 사토시 나카모토**가 비트코인 백서를 발표하면서 블록체인의 개념이 구체화
중앙기관 없이도 개인간(P2P)송금가능
이중 지불(Double Spending)문제해결
높은 수수료와 거래 속도 문제 개선

타임스탬프는 데이터가 생성되거나 변경된 시간정보를 기록하는 것을 의미
주요기능
데이터 무결성보장(변조 방지)
순서 보장(이전 기록과의 관계유지)
보안성 강화(전자 문서, 금융 거래 인증)
이력관리(로그 데이터 저장)

예시(UTC형식): 2025-02-03ㅅT14:35:22Z (ISO 8601형식)

-2울4일-
해시(Hash)는 데이터를 압축하고 고정된 크기의 출력 값

데이터의 무결성을 확인/ 암호학적 보안 제공

-단방향성

해시값에서 원래 데이터를 되돌릴 수 없음

망고에서 망고주스 O

망고주스에서 망고 X

-충돌 저항성

서로 다른 입력 값이 같은 해시 값을 가질 확률이 극히 낮음

-빠른 연산 속도

블록체인에서 해시는 빠르게 계산 할 수 있어 블록체인 트렌젝션 검증과 무결성 확인에 사용 

해시의 역할 

1. 블록의 고유 식별자 역할

블록체인의 각 블록은 이전 블록의 해시 값을 포함하여 연결

하나의 블록이 변조될 경우 이후 모든 블록의 해시 값이 바뀌어 변조를 쉽게 탐지

1. 트렌젝션 무결성 검증

트렌젝션이 해시 값을 사용하여 기록

3.마클 트리 구조

블록체인에서 트렌젝션 데이터를 효율적으로 관리하기 위해 해시 트리를 사용 

트렌젝션들의 해시 값을 결합하여 최종적으로 하나의 해시 값(머클 루트)을 만듦

이를 통해 빠르게 데이터의 무결성을 검증

블록체인 대표 해시 함수

1. SHA-256

비트코인, 이더리움 등에서 사용되는 해시 함수

256비트의 고정된 길이 출력 값을 생성

1. Keccak -256 (SHA-3)

이더리움에서 사용되는 해시 함수

SHA-256과 유사하지만 구조적으로 조금 다름

1. RIPEMD-160

비트코인의 주소 생성 과정에서 사용됨

SHA-256을 거친 후, RIPEMD-160을 적용하여 짧은 해시 값을 생성

-블록 해시(block hash)

해당 블록의 고유한 식별자로 사용되는 해시값

-블록 해시 값 생성 인자(데이터)

1. 이전 블록의 해시값
2. 머클루트(merkle root): 블록 내 모든 트렌잭션의 요약 값
3. Timestamp
4. 난이도 목표(Difficulty Target): 작업 증(poW)에서 필요한 해시의 난이도
5. 논스(Nonce): 작업 증명을 완료하기 위해 반복적으로 변경되는 값

→위의 데이터를 결합하여, SHA-256 해시 함수를 두번 적용해서 블록 해시 값을 생성

작업 증명 (poW)

블록체인의 합의 알고리즘 중 하나로 새로운 블록을 추가할 때 특정한 연산 작업(채굴)을 수행해야하는 방식 

네트워크의 보안을 유지하고, 트렌잭션을 검증하며, 분산 합의를 이루기위해 사용

트렌잭션 ID(TXID)

블록체인에서 특정 트렌잭션을 식별하는 고유한 해시 값

입력, 출력, 금액 등이 데이터에 포함

머클 트리(Merkle tree)

블록체인에서 트렌잭션 데이터를 효올적으로 검증하고  저장하기위해 사용되는 트리구조의 데이터 구조

각 노드는 트렌잭션 데이터의 해시 값이며, 부모 노드는 자식 노드 두개의 해시 값을 결합하여 다시 해싱한 값으로 구성됨

-머클트리의 역할

1. 블록체인의 데이터 무결성 보장
2. 뻐른 트랜젝션 검증(SPV,간이 검증)
3. 효율적인 데이터 저장

비트코인 주소 생성

비트코인의 주소 체계에는 비대칭키 암호화를 기반으로 생성되는데, 이 비대칭키 암호화에서는 공개키와 비밀키가 사용됨

디지털 서명 

트렌잭션의 무결성을 보장, 소유권을 증명하는 암호화 기술

-디지털 서명의 동작과정

1. 해싱(Hashing)

원본 메시지를 해시 함수로 변환하여 고정된 길이의 해시 값을 생성

1. 서명(Signing)

생성된 해시값을 서명자의 개인키로 암호화하여 디지털 서명 생서

1. 검증 (Verification)

수신자는 서명자의 공개키를 사용하여 서명이 올바른지 검증

암호화 (Encryption)

데이터를 보호하기 위해 원본 정보를 특정 알고리즘을 사용하여 변환하는 과정 

암호화된 데이터는 허가된 사용자만 복호화(Decryption)하여 읽을 수 있도록 보안성을 제안

은닉(Confidentiality)

데이터를 암호화하여 비인가된 사용자가 해당 데이터를 읽지 못하도록 보호하는 개념

증명(Integrity and Authenticity)

암호화를 이용하여 데이터의 무결성과 인증을 보장하는 개념

디지털 서명이 암호화의 증명에 사용

복호화(Decryption)

암호화 과정에서 사용한 동일한 키로 암호문을 다시 평문으로 변환

과정

평문→암호화 알고리즘→암호문  암호문→복호화 해독키→평문

암호화의 유형

-대칭키 암호화

암호화와 복호화에 동일한 키를 사용

빠르고 효율적, 키를 안전하게 공유하는 것이 어려움

사용예시: 개발팀 환경셋팅, 금고 열쇠, 공용 비밀번호

-비대칭키 암호화

공개키(Public key)와 개인키(Private key)를 사용

공개키로 암호화, 개인키로 복호화 가능

대칭키보다 속도가 느림

-2월 5일-
비트코인의 구조

1. 블록 헤더(Header) - 블록의 메타데이터
2. 트랜젝션 리스트- 블록에 포함된 모든 트랜젝션

-헤더 구조 

크기 80바이트로 고정

주요 구성 요소

- 이전 블록해시 (Previous Block Hash)

이전 블록의 해시 값으로, 블록 간 연결성을 제공

체인형성, 무결성 보장

- 머클 루트 (Merkle Root)

블록 내 모든 트랜젝션을 하나의 해시로 표현

블록 내 모든 트랜잭션이 변경되지 않았음을 증명

- 타임스탬프 (Timestamp)

블록이 생성된 시간

UNX 타임스탬프 형식으로 저장

- 난이도 타겟 (Difficulty Target)

현재 블록 생성 난이도

네트워크의 작업 증명(Proof of Work) 목표를 정의

- 논스 (Nonce)

채굴자가 채굴할 때 변경하는 값(작업증명,poW)

- 버전(Version)

블록이 사용하고 있는 비트코인 프로토콜 버전 정보

-블록 바디 (1MB~4MB)

블록에 포함된 트랜잭션 데이터를 저장

- 코인베이스 트랜잭션 (Coin Transaction)

가장 첫번째 트랙잭션 (채굴자)

블록보상 (채굴보상 + 트랜잭션 수수료)지급을 위한 특별한 트랜잭션

- 일반 트랜잭션 (Transactions)

블록에 포함된 모든 비트코인 전송 기록

트랜잭션의 개수는 네트워크의 상태. 트랜잭션 용량에 따라 달라짐

트랜잭션은 입력(Input), 출력(Output)으로 구성

- 트랜잭션 구조

비트코인이 한 주소에서 다른 주소로 이동하는 데이터 구조

입력, 출력, 수수료로 구성, 각 트랜잭션은 디지털서명을 포함해 보안 유지

- 트랜잭션의 주요 구성 요소
1. 버전 

트랜잭션의 버전

1. 입력

이전 트랜잭션의 출력(UXTO)을 사용하여 새로운 트랜잭션을 생성/ 송신자의 서명이 포함된 정보

-입력 구성요소 

트래잭션 해시( Transaction Hash) 32바이트

현재 트랜잭션이 참조하는 이전 트랜잭션의 해시값

출력 인덱스( Output Index) 4바이트

참조하는 트랜잭션에서 어떤 출력을 사용하는지

지출할 UTXO

스크랩트 길이 (Script Length) 가변

잠금 해제 스크립트의 길이

스크립트 서명 (ScriptSig)

이전 트랜잭션 출력의 소유권을 증명하기 위한 서명과 공개키로 구성된 스크립트

공개키와 디지털 서명이 포함

시퀸스 번호 (Sequence Number) 4바이트

트랜잭션이 취소되거나 수정될 가능성을 나타내는 피드 

현재는 사용 X

1. 출력 (Output)

수신자에게 전딜되는 비트코인의 정보를 포함

한 트랜잭션은 여러개의 출력을 가질 수 있음

-출력 구성요소

출력금액(Value) 8바이트

해당 출력에 포함된 비트코인의 금액

단위: 사토시 ( 1비트코인 = 10^8사토시)

스크립트 길이 (Script Length) 가변

잠금 스크립트의 길이

잠금 스크립트 (Script Length)

비트코인을 잠금(수신자의 주소를 설정)하는 스크립트

일반적으로 P2PKH스크립트 형식 (수신자의 주소를 포함)

트랜잭션 카운터 (Transaction counter) 4바이트

해당 트랜잭션이 유효해지는 조건을 나타냄

- UTXO (Unspent Transaction Output)

사용되지 않은 비트코인의 트랜잭션 출력

비트코인은 계좌기반이 아닌 UTXO모델을 사용하여 코인의 잔액을 추적

사용자가 BTC를 보낼때 기존의 UTXO를 입력으로 사용하여 새로운 트랜잭션을 생성, 남은 잔액을 새로운 UTXO로 변환

- UTXO의 주요 특징

-이중 지불 방지 (Double Spending Prevention)

한 번 사용된 UTXO는 재사용 불가

채굴자는 트랜잭션을 검증할 때, 해당 UTXO가 이전에 사용되지 않았는지 확인

-잔도 개념 필요

기존 화폐처럼 잔돈을 돌려받는 방식

전송이후 잔돈은 새로운 UTXO가 생성 (출력 2개)

-데이터의 투명성과 무결성 유지

블록체인에서 모든 UTXO 공개적으로 조회 가능

사용된 트랜잭션은 더 이상 유효하지 않으므로 데이터 변조 불가

-병령 처리 기능 (Scalability)

각 UTXO는 독립적으로 관리되므로, 여러 개의 트랜잭션을 동시에 처리가능

UTXO의 장점과 단점

-장점

**이중 지불 방지** → 각 UTXO는 한 번만 사용 가능하여 보안성이 높음

**투명성 및 보안성** → 모든 트랜잭션이 블록체인에 기록됨

**병렬 처리 가능** → 독립적인 UTXO 구조 덕분에 병렬 트랜잭션 처리 가능

-단점

복잡한 잔돈관리 → 트랜잭션 처리 시 추가적인 데이터가 필요

저장소 부담 → 전체 네트워크의 UTXO 데이터를 유지하는데 상당한 저장소 필요

- 스크립트 (Script)

UTXO를 소비하기 위해 스크립트 언어를 통해 트랜잭션의 유효성 확인해야되며, 연산자 코드가 그 과정을 담당하게 됨

**UTXO의 소유권 검증**: OP_CHECKSIG와 OP_HASH160을 활용하여 소유자를 확인

**정확한 출력 검증**: OP_EQUAL과 OP_VERIFY를 통해 출력 주소와 금액이 올바른지 확인

**보안성 강화**: OP_DUP과 OP_CHECKMULTISIG로 다중 서명 및 공개 키 변조 방지

- 머클 트리 (Merkle Tree)

트랜잭션 데이터를  계층적으로 해시(hash)하여 저장하는 트리구조

각 트랜잭션을 해시한 후, 상위 노드에서 다시 해시하여 최종적으로 하나의 해시 값(머클루트)을 생성

전체 데이터의 무결성을 간단한 머클 루트 값 하나로 증명 가능

- 머클 트리 생성 과정

**각 트랜잭션 데이터를 해시(SHA-256)하여 리프 노드(Leaf Node) 생성**

**두 개의 해시 값을 결합하여 다시 해시 → 부모 노드 생성**

**이 과정을 반복하여 하나의 최종 해시 값(머클 루트)이 남을 때까지 계속 수행**

- 머클 루트 (Merkle Root)

머클 트리의 최상단(루트) 해시 값, 블록에 포함된 모든 트랜잭션을 대표하는 해시 값

블록 내 모든 트랜잭션의 무결성을 증명하는 역할

- **머클 트리의 주요 기능**

**-데이터 무결성 보장**

머클 루트 값이 변하면 블록 내 트랜잭션이 변경되었음을 의미

블록체인 조작이 불가능하도록 보안 강화

**-빠른 데이터 검증** (머클 프로프, Merkle Proof)

전체 트랜잭션을 다운로드하지 않고도 특정 트랜잭션이 포함되었는지 검증 가능

라이트 노드(SPVs, Simplified Payment Verification)에서 사용됨

**-트랜잭션 데이터 저장 효율성 증가**

개별 트랜잭션 해시만 저장하면 되므로 데이터 저장 공간 절약

**-블록체인 구조 최적화**

모든 트랜잭션을 한 번에 처리하는 것이 아니라 해시값을 활용하여 연산량 감소

2/6

- 중앙 집중형 원장

데이터가 하나의 중앙 기관(은행, 회사, 정부 등)에 의해 관리, 통제되는 방식

- 중앙집중형 원장의 특징

-중앙화된 신뢰: 중앙 기관의 신뢰성과 권위를 기반으로 형성

예: 은행은 거래테이터를 관리, 보증

-단일 장애점 (Single point of failure):

중앙 서버가 해킹, 손상, 장애를 겪으면 데이터가 유실되거나 손상될 위험이 있음

-효율성: 중앙 기관이 데이터를 직접 관리하여 데이터 처리 속도가 빠름

예: 은행 간 정산 시스템

-투명성 부족: 중앙 기관이 데이터를 독점적으로 관리하므로, 참여자는 데이터를 직접 검증하거나 확인할 수 없음

- 분산 원장 (Distributed Ledger)

-중앙 기관 없이 네트워크 참여자들이 데이터를 분산 저장하고, 동기화하며, 관리하는 디지털 원장

-기존의 중앙 집중형 데이터 베이스와 달리, 분산 원장은 여러 노드(컴퓨터)에 동일한 데이터를 복제하여 저장하며, 모든 변경사항이 네트워크 전체에 동기화됨

-데이터의 무결성과 보안 유지

-블록체인은 분산 원장의 한 형태 (블록체인 **≠ 분산원장)**

- 분산 원장의 특징

-분산성: 데이터가 네트워크의 여러 노드에 분산 저장되므로 중앙 서버 불필요

-변경 불가능성: 데이터가 기록된 후 변경 또는 삭제하기 어려움

(데이터의 무결성)

-투명성: 모든 참여자가 동일한 데이터를 볼 수 있어 신뢰 제공

-탈중앙화: 중앙 권한없이 합의를 통해 데이터 추가,수정

- 분산원장의 종류

-퍼블릭 분산원장: 누구나 접근 가능하며, 퍼블릭 블록체인 (예: 비트코인, 이더리움)

-프라이빗 분산원장: 제한된 참여자만 접근 가능, 기업 내부에서 사용 (예: 하이퍼레저)

-컨소시엄 분산원장: 특정그룹 (기업 연합 등) 내에서 공유되며, 참여 노드 제한

- **분산 원장의 활용 사례**

**-금융(Finance)** → 비트코인, 스마트 컨트랙트, 중앙은행 디지털화폐(CBDC)

-**공급망 관리(Supply Chain)** → 제품의 생산부터 유통까지 투명하게 추적

- **헬스케어(Healthcare)** → 의료 기록을 안전하게 관리하고 공유

- **전자 투표(Electronic Voting)** → 조작이 불가능한 온라인 투표 시스템 구축

-**저작권 보호(Digital Rights Management)** → 음악, 영상, NFT 등의 디지털 자산 보호

- 분산 원장 핵심 기슬 (DLT)

-합의 알고리즘: 분산 원장에서 네트워크의 모든 노드가 데이터의 유효성과 순서를 검증하고, 동일한 기록을 유지하기위해 사용하는 방식 (예: poW, poS, PBFT)

-암호화: 데이터의 기밀성, 무결성, 사용자 신원을 인증하기 위해 암호화 기술 사용, 이를 통해 데이터 위변조와 부인을 방지

-노드(Node) 동기화: 모든 노드가 동일한 데이터를 유지하도록 동기화 과정을 거치며, 네트워크의 데이터 일관성, 무결성 보장

- 노드

-분산원장 또는 블록체인 네트워크에서 데이터를 저장, 관리, 다른 노드와 데이터를 교환하는 컴퓨터, 장치

-노드가 많을수록 네트워크가 더욱 탈중항화되고 보안성이 강화됨

-모든 노드는 동일한 데이터를 공유하므로, 일부 노드가 손상되거나 중단되어도 네트워크는 계속 운영됨

- 노드의 역할

**-트랜잭션 검증 (Transaction Validation)** → 새로운 트랜잭션이 유효한지 확인

**-블록 저장 (Block Storage)** → 블록체인 데이터(거래 기록)를 저장

- **네트워크 전파 (Network Propagation)** → 트랜잭션과 블록을 다른 노드에 전송

**-합의 프로세스 참여 (Consensus Participation)** → PoW, PoS 같은 합의 알고리즘 수행

- 노드의 유형

-풀노드 (Full Node):

블록체인의 모든 데이터를 저장하고, 트랜잭션과 블록의 유효성을 독립적으로 검증하는 노드

블록체인의 안전성과 무결성을 유지하는데 핵심적인 역할

예: 비트코인 풀 노드, 이더리움 Geth

-라이트 노드 (Light Node) or SPV 노드(Simple Payment Verification):

블록체인의 전체 데이터를 저장하지 않고, 트랜잭션을 빠르게 검증하는 노드

블록체인의 80바이트 크기의 블록 헤더만 다운로드, 머클루트를 통해 블록 바디 없이도 블록에 포함되었는지 검증 가능

트랜잭션 세부 내열 검증을 위해 풀 노드의 지원 필요

예: 모바일 지갑

-마이닝 노드 (Mining Node):

작업 증명(poW)을 수행하여 새로운 블록을 생성하는 노드

합의 알고리즘에 참여, 블록 보상을 통해 인센티브 

구조적으로 풀 노드와 동일, 비트코인 백서에는 마이닝 노드 키원드 X

예: 비트코인 채굴자, 이더리움 검증자

-검증 노드 (Vaildator Node):

PoS 네트워크에서 블록을 검증하고 합의 과정에 참여하는 노드

에: 이더리움 2.0, 카르다노, 솔라나

-아카이브 노드 (Archive Node):

블록체인의 모든 기록과 상태 데이터를 저장하는 노드

특정 트랜잭션의 과거 기록을 조회하거나 블록체인의 전체 상태를 분석하는데 사용

스마트 컨트랙트가 실행되는 블록체인에 사용

- 비트코인 블록 생성 과정
- 비잔틴 문제(**Byzantine Generals Problem)**

분산 시스템에서 일부 노드가 악의적으로 행동하거나 오류를 일으켜도, 나머지 노드들이 올바른 결정을 내릴 수 있도록 하는 방법을 찾는 것이 핵심

- 비잔틴 장애 허용 (BFT, Byzantine Fault Tolerance)

-네트워크 내 일부 노드가 악의적이거나 오류를 발생시켜도, 나머지 정직한 노드가 올바른 합의에 도달하여 시스템이 정상적으로 작동하도록 보장하는 메커니즘

-모든 분산 노드 체계에선 비잔틴 장애를 해결해야함

-비잔틴 장애: 분산 시스템에서 노드 간의 신뢰 문제가 발생했을 때, 어떻게 모든 정직한 노드가 합의에 도달할 수 있는지를 설명하기 위한 개념

PoW: 작업 증명을 통해 BFT해결

PoS: 지분 증명을 통해 BFT해결

- PoW 작업증명 (Proof of Work)

블록체인 네트워크에서 거래를 검증하고 새로운 블록을 생성하는 합의 알고리즘

poW는 채굴자들이 복잡한 암호학적 연산(해시퍼즐)을 해결해야 블록을 생성할 수 있는 방식

예: 비트코인,이더리움 1.0

- PoW의 핵심개념:

채굴자들이 수학적 퍼즐을 해결하여 블록을 추가하는 방식

**네트워크 보안 유지** → 악의적인 사용자가 블록체인을 조작하기 어렵게 만듦

**경쟁적인 블록 생성** → 많은 채굴자들이 경쟁하여 새로운 블록을 추가

**연산력 기반의 합의 방식** → 더 많은 연산력을 가진 노드가 블록 생성 가능성이 높음

- **PoW의 특징:**

**채굴(Mining)** → 컴퓨터가 연산을 수행하여 해시 퍼즐을 해결

**보안성** → 연산량이 많아질수록 공격이 어려워짐

**속도 문제** → 트랜잭션 처리 속도가 느림(비트코인: 약 10분/블록)

**높은 에너지 소비** → 대량의 전력 사용

- 이더리움 (Ethereum

스마트 컨트랟트( Smart Contract)의 분산 애플리케이션(DApp)을 실행할 수있는 확장 가능한 블록체인 플랫폼

창시자: 비탈릭 부테린 

-비트코인에 튜링 안정성을 추가하자 제안

-거절이후 프로그램밍 가능한 블록체인 이더리움 개발

- 이더리움 구조

노드, 트랜잭션 모델, 스마트 컨트랙트, EVM, 합의 알고리즘 등으로 구성

- 이더리움의 핵심 기술

**스마트 컨트랙트** → 블록체인에서 실행되는 자동화된 계약

**EVM (Ethereum Virtual Machine)** → 모든 스마트 컨트랙트를 실행하는 가상 머신

**PoS 합의 알고리즘** → 기존 PoW에서 PoS로 전환하여 확장성과 보안 강화

- 블록체인 모델

이더리움- 어카운트 기반 모델 (Account-based)

모든 사용자와 스마트 계약이 계정으로 표현되며, 계정을 통해 상태(State)와 자산관리

- 계정 종류:

-외부 소유 계정(Externally Owned Account, EOA):

개인이 소유한 계정, 비공개 키에 의해 제어

트랜잭션 생성 가능

-스마트 계약 계정(Contract Account)

특정 코드 (Smart Contract)가 배포된 계정

트랜잭션이 발생하면 해당코드 실행

- 계정 상태

-Nonce: 해당 계정에서 보낸 트랜잭션 수

Balance: 계정에 저장된 이더의 양

Storage: 스마트 계약 데이터(스마트 계약 계정에만 해당)

를 통해 계정 종류 확인 가능

CodeHash: 스마트 계약 코드(스마트 계약 계정 해당)

- 트랜잭션 방식

계정 간에 트랜잭션을 보내 상태 병경

이더를 전송사거나,스마트 계약을 호출하는 트랜잭션

비트코인 VS 이더리움

비트코인: 디지털 화폐

디지털 골드 or p2p 전자화폐의 역할을 목표로 함

중앙 은행 없이 탈중화된 금융 시스템 구축

확장성 및 프로그래밍 기능 제한

이더리움: 탈중앙화된 글로벌 컴퓨터

스마트 컨트랙트를 실행하는 플랫폼

DApp과 DeFi가능

네트워크사의 모든 트랜잭션은 EVM을 통해 실행됨

1. 스마트 계약(Smart Contract)

-블록체인에서 실행되는 자동화된 계약(프로그램)으로, 조건이 충족되면 자동으로 실행되는 코드

-중앙 기관 없이 탈중화된 방식으로 거래, 계약 이행, 데이터 처리가 가능

-이더리움이 최초로 스마트 컨트랙트 기능을 제공, 이후 다양한 블록체인들이 체택

**특징:**

**자동 실행** → 계약 조건이 충족되면 즉시 실행

**변경 불가능(Immutable)** → 배포 후 코드 변경 불가능 (업그레이드는 가능)

**투명성** → 블록체인에 기록되므로 누구나 검증 가능

**보안성** → 중앙 서버 없이 실행되므로 해킹 위험 감소

